# 14-2. 페이징을 통한 가상 메모리 관리

### 학습목표

- 페이징 기법의 배경과 작동 원리를 이해한다.

### 페이징이란?

![Untitled](14-2%20페이징을%20통한%20가상%20메모리%20관리_assets/1f3b8250b8ff05fa7ff929b393f296fdf44e9380.png)

- 메모리와 프로세스를 일정 단위로 자르고, 이를 메모리에 **불연속적으로 할당**하는 기법
  - 프로세스 → 페이지, 메모리 → 프레임
  - 논리 주소 **페이지를** 물리 주소 **프레임에 할당**
  - 스와핑을 페이지 인 - 페이지 아웃으로도 부른다.

### 페이지 테이블

![Untitled](14-2%20페이징을%20통한%20가상%20메모리%20관리_assets/3d41e00637643e66595119d27d2d73d266781313.png)

- 불연속 배치로 인하여 문제가 발생한다.
- CPU 입장에서 다음에 실행할 명령어 위치를 찾기 어려워진다.
- 페이지 테이블은 **현재 어떤 페이지가 어떤 프레임에 할당되었는지**를 알려준다.
- 페이지의 크기가 작아질수록, 페이지 테이블은 커진다.

### 페이지 테이블 베이스 레지스터(PTBR)와 TLB

![Untitled](14-2%20페이징을%20통한%20가상%20메모리%20관리_assets/5abe083bc54b3f6841f9b66a8df73fa791e1423d.png)

- CPU 내의 PTBR은 페이지 테이블이 적재된 주소를 가리킨다.
- 페이지 테이블은 메모리에 있기 때문에 메모리에 2번 접근해야 한다.
- 따라서 TLB라는 캐시 메모리를 활용하여 페이지 테이블의 일부 내용을 저장한다.

### ※ 내부 단편화

- 모든 프로세스가 페이지 크기에 딱 맞게 잘리지는 않으므로 메모리 누수 발생
- 적절한 페이지 크기 조절이 필요함.

### 페이지 테이블의 구조

1. 유효 비트
   - 페이지가 메모리에 있는가(1) 보조기억장치에 있는가(0)
   - page fault 예외 처리
2. 보호 비트
   - Read(r)
   - Write(w)
   - eXecute(x)
3. 참조 비트
   - CPU가 접근한 적이 있는가
4. 수정 비트
   - 페이지에 데이터를 쓴 적이 있는가(1) 없는가(0)
   - 만약 1이라면 페이지가 스왑될 때 보조기억장치에 변경된 값을 기록하는 작업이 필요하다.

---

지난 단원 복습 시간

### 페이징에서의 주소 변환

![Untitled](14-2%20페이징을%20통한%20가상%20메모리%20관리_assets/77c313272f818ef1a4f8d354da57b781c76cfe2b.png)

### 계층적 페이징

![Untitled](14-2%20페이징을%20통한%20가상%20메모리%20관리_assets/d877959f9883e3d260771db56e04825ff291d0bc.png)

- like 2차원 배열